\section{Введение}

Большая часть современного программного обеспечения написана на языках, позволяющих  динамически выделять память, таких как \texttt{C++}, \texttt{Java}, \texttt{C\#}. Автоматический анализ программ на таких языках является трудоёмкой задачей~\cite{distefano2009attacking}. При этом даже корректные с теоретической точки зрения методы анализа могут оказаться неэффективными на реальных индустриальных проектах из-за их размеров~\cite{calcagno2011compositional}. Для решения проблемы масштабирования анализа на большие проекты были предложены различные \emph{композициональные} техники анализа программ, которые хорошо зарекомендовали себя на практике~\cite{gurfinkel2015seahorn,anand2008demand,distefano2008jstar,calcagno2011infer}. Такие техники подразумевают анализ функций в \emph{изоляции}, то есть вне контекста конкретного вызова, и переиспользование артефактов анализа. Таким образом можно свести верификацию больших систем к задаче верификации набора небольших фрагментов кода.

Идея композиционального анализа представляется вполне естественной ввиду модульной природы программного обеспечения. Однако большинство существующих композициональных техник являются \emph{неточными} в том смысле, что они аппроксимируют снизу или сверху пространства состояний программы. Типичная аппроксимирующая снизу техника может заключаться в конечной раскрутке циклов и рекурсии или исполнении некоторых функций на конкретных значениях, например~\cite{tillmann2008pex}. Аппроксимирующие сверху техники, такие как абстрактная интерпретация~\cite{cousot1977abstract}, как правило работают в абстрактном домене. Простым примером такого домена может быть $\{+, -, 0\}$ для анализа программ с целыми числами. Анализатор с этим доменом будет интерпретировать инструкцию \lstinline{x := 42} как \lstinline{x := +}, что позволит рассуждать о знаках переменных, но не о их точных значениях.

В данной работе представлен формализм, позволяющий проводить \emph{точный} композициональный анализ программ с динамической памятью. Он основывается на концепции \emph{композициональной символьной памяти}. На базе указанного формализма строится подход к модульной верификации императивных программ с динамической памятью, функциями высшего порядка и неограниченной рекурсией. Совмещение композициональной символьной памяти и широко известной техники композиционального символьного исполнения~\cite{godefroid2007compositional} позволяет построить фреймворк точного модульного анализа.

Композициональная символьная память является расширением классической модели символьной памяти. Расширение заключается в том, что значения в \emph{символьных кучах} могут представляться \ruquote{ленивыми} \emph{ячейками}, аналогично методам ленивого инстанцирования~\cite{khurshid2003generalized}. Содержимое такой ячейки~--- источник символьного значения~--- может быть символьным выражением над другими ячейками, что позволяет кодировать поведение функций, работающих с произвольными рекурсивными типами данных. В данной работе представлена формальная модель композициональной символьной памяти и доказаны некоторые свойства, показывающие её применимость.

Также в работе представлено исчисление, обобщающее концепцию символьных куч. Главное достоинство этого исчисления в том, что оно даёт возможность символьно исполнять императивные программы с динамической памятью без раскрутки циклов и рекурсивных функций, позволяя избежать проблемы взрыва путей исполнения. Предлагаемое исчисление позволяет движку символьного исполнения \emph{точно} описать все поведения функции, породив некоторый набор \emph{уравнений на состояния}.

Решение таких уравнений требует использования достаточно мощного фреймворка логических рассуждений и синтеза индуктивных инвариантов. Вместо принятых в символьном исполнении SMT-решателей, предлагается использовать \emph{решатели дизъюнктов Хорна с ограничениями} (constrained Horn clauses)~\cite{bjorner2015horn}. Непосредственное кодирование уравнений над состояниями даёт дизъюнкты Хорна \emph{высшего порядка}~\cite{cathcart2017higher}, которые могут быть сведены к дизъюнктам первого порядка при помощи фреймворков вывода ограниченных (refinement) типов~\cite{vazou2015bounded,unno2013automating,zhu2013compositional}.

На предлагаемое в данной работе исчисление можно смотреть как на алгоритм построения соответствия между программами с динамической памятью и чистыми функциями второго порядка. В качестве побочного эффекта, этот алгоритм позволяет транслировать произвольные императивные программы с динамической памятью в функциональные языки. Композициональная природа предлагаемого подхода позволяет получать функциональные программы, похожие по структуре на изначальные.

Основные результаты данной работы:
\begin{enumerate*}
    \item концепция композициональной символьной памяти;
    \item доказательства её свойств;
    \item понятия \emph{обобщённых символьных куч} и \emph{уравнений на состояния}, исчисление для их построения и упрощения;
    \item алгоритм композиционального символьного исполнения императивных программ с динамической памятью без раскрутки;
    \item сведение уравнений на состояния к дизъюнктам Хорна с ограничениями.
\end{enumerate*}
