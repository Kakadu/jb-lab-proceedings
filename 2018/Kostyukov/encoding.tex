\section{Решение уравнений на состояния}
\label{sec:encoding}
Для проверки достижимости некоторого пути исполнения программы,~\autoref{algo:compositional-se} обращается к функции-оракулу \emph{isSatisfiable}. В данной секции мы определяем \emph{isSatisfiable} и тем самым завершаем построение композициональной процедуры верификации.

Пусть $g$~--- ограничение, выполнимость которого необходимо проверить, а $rhs$~--- отображение рекурсивных символов в правые части уравнений на состояния. Мы сведём задачу выполнимости $g$ к задаче выполнимости дизъюнктов Хорна с ограничениями. Это можно сделать напрямую, однако мы проделаем это за два шага: сведём уравнения на состояния к чистым функциям второго порядка\footnote{Функцией \emph{первого порядка} называется функция, которая не принимает в аргументы других функций. Функцией \emph{второго порядка} называется функция, которая принимает в аргументы функции только первого порядка~--- и не выше.}, а затем закодируем проблему безопасности этих функций в дизъюнкты Хорна с ограничениями. Промежуточный шаг может быть интересен тем, что позволяет транслировать императивные программы с динамической памятью в чистые функции (см.~\autoref{apdx:haskell}).

\subsection{Трансляция уравнений на состояния в функции второго порядка}
Будем говорить, что символьный терм $t$ находится в \emph{нормальной форме}, если он содержит объединения только на верхнем уровне, т.е. $t=\union{\pair{g_1}{t_1},\ldots,\pair{g_n}{t_n}}$ и ни один из $g_i$ или $t_i$ не содержит внутри $\aunion$. Будем также говорить, что \emph{ограничение} находится в нормальной форме, если оно не содержит объединений вообще. Каждое символьное выражение может быть нормализовано: по~\autoref{prop:union-properties} и~\eqref{eq:li-constraint}, вложенные объединения могут быть линеаризованы. Если $t$ не содержит объединений, тогда его нормальной формой будем называть $\aunion\pair{\top}{t}$. Ограничение $g \equiv \union{\pair{g_1}{c_1},\ldots,\pair{g_n}{c_n}}$ может быть переписано в $(g_1\wedge c_1) \vee \ldots \vee (g_n\wedge c_n)$.

Рассмотрим символьную ячейку $\li{\sigma, x}$. Заметим, что такие ячейки с $\sigma\neq\emptyheap$ появляются только в последней ветке определения~\eqref{eq:find-new}, т.е. можно рассматривать $\li{\sigma, x}$ как $\findnew{\sigma}{x}{\emptyheap}$. Уточнение такого выражения в контексте $\tau$ даст $\fillterm{\tau}{\findnew{\sigma}{x}{\emptyheap}}\eqby{Lm.\ref{thm:composition-of-find}}\findnew{\sigma}{\fillterm{\tau}{x}}{\tau}$. Это даёт возможность транслировать символьные выражения в функции второго порядка.

Далее, за $\tau$ обозначим функцию первого порядка: чтение из контекстной кучи. Преобразование символьного выражения $e$ в выражение функционального языка при контекстной куче $\tau$ обозначим за $\convtau{e}$. Это преобразование состоит из трёх шагов:
\begin{enumerate}
\item нормализация $e$ и преобразование верхнеуровневого объединения в конструкцию ветвления;
\item замена всех ячеек $\li{\sigma, x}$ на $\findnew{\sigma}{\convtau{x}}{\tau}$;
\item \emph{специализация} оператора $\afind$ согласно правилам~\eqref{eq:find-new}. На этом шаге все термы вида $\findnew{\sigma}{x}{\tau}$ транслируются в применения функций второго порядка \texttt{find}$_\sigma$. Телом функции \texttt{find}$_\sigma$ будет результат применения этих трёх шагов к соответствующему правилу~\eqref{eq:find-new}. При появлении композиции $\gcompose{\sigma}{\sigma'}$ контекстное состояние становится частичным применением \texttt{find}$_{\sigma}$ к текущему контекстному состоянию $\tau$.
\end{enumerate}

Вместо формального описания целевого языка программирования и алгоритма трансляции мы продемонстрируем его на примере. Пусть $rhs(f)=\GMerge{\pair{c}{\emptyheap},\pair{\neg c}{\GCompose{\sigma}{\grec{f}}}}$, где $\sigma$~--- это некоторая обобщённая куча. Допустим, необходимо проверить выполнимость ограничения $g = \li{\grec{f}, a} * 3 < 17$.

Сначала определим контекстную функцию первого порядка $\tau_0$, которая будет принимать адрес и выполнять ленивую инстациацию символьных локаций, т.е. возвращать недетерминированные значения. Далее, вычислим $\conv{g}{\tau_0}$.

Первый шаг не порождает условных конструкций. После второго шага выражение становится следующим: $\finDnew{\grec{f}}{a}{\tau_0} * 3 < 17$. Третий шаг порождает новую функцию второго порядка \texttt{find}$_f$. Таким образом, закодированное значение $g$ будет
\[
	\conv{g}{\tau_0} = (\papplyt{\texttt{find}_f}{\tau_0}{a}) * 3 < 17
\]

Проверить выполнимость $g$~--- это то же самое, что проверить безопасность программы \mbox{``\texttt{assert($\neg$ g)}''}.

Теперь мы должны задать тела полученных функций $find$. Пусть \texttt{find}$_f$ принимает контекстную функцию первого порядка $\tau$ и локацию $x$. Тело функции \texttt{find}$_f$ мы получим применяя шаги 1---3 к правой части уравнения на состояние $f$:
\begin{align*}
&\Findnew{\GMerge{\pair{c}{\emptyheap},\pair{\neg c}{\gcompose{\sigma}{\grec{f}}}}}{x}{\tau}~\eqbyref{eq:find-new}\\
&\qquad=\Ite{\fillterm{\tau}{c}}{\findnew{\emptyheap}{x}{\tau}}{\findnew{\GCompose{\sigma}{\grec{f}}}{x}{\tau}}
\end{align*}

Это объединение будет нормализовано и транслируется в ветвление в теле \texttt{find}$_f$; ленивые ячейки в $c$ заменятся применениями $\afind$, которые будут также специализированы. Итеративное применение этих шагов даст следующий код для $g$:
\begin{lstlisting}[basicstyle=\small,escapechar=@]
assert@$\big($@(find@$_f$@ @$\tau$@ a) * 3 @$\not<$@ 17@$\big)$@

find@$_f$@ @$\tau$@ x =
	if @$\convtau{c}$@ then find@$_\emptyheap$@ @$\tau$@ x
	else find@$_{\compose{\sigma}{f}}$@ @$\tau$@ x

find@$_\emptyheap$@ @$\tau$@ x = @$\tau$ x@

find@$_{\compose{\sigma}{f}}$@ @$\tau$@ x = find@$_f$@ (find@$_{\sigma}$@ @$\tau$@) x

... specialized find@$_\sigma$@ ...

\end{lstlisting}

Основной трюк такой трансляции состоит в том, что композиции могут быть заменены частичными применениями функций. Это позволяет сохранять свойство того, что контекстные функции не поднимаются выше первого порядка. Таким образом получается трансляция в чистые функции второго порядка.

\begin{remk*}
Есть несколько способов улучшить эту трансляцию. Во-первых, можно специализировать не только по куче, но и по типу локации, что даст более специализированные функции. Это также необходимо, чтобы получить из алгоритма трансляции типобезопасные функции. Во-вторых, полученная программа может быть частично исполнена, чтобы удалить тривиальные чтения, как например \texttt{find}$_{\emptyheap}$. В-третьих, именованные локации могут передаваться как обычные аргументы, так как их адреса никогда не меняются. Эти три улучшения позволяют получить автоматическую трансляцию, чьи результаты будут схожи с \autoref{apdx:haskell}.
\end{remk*}

\subsection{Трансляция функций второго порядка в дизъюнкты Хорна первого порядка с ограничениями}
Для доказательства безопасности чистых функций высшего порядка можно применить различные классические техники. Одной из самых успешных среди них является \emph{вывод ограниченных типов} (refinement type inference)~\cite{vazou2015bounded,unno2013automating,zhu2013compositional,cathcart2017higher}. Фреймворки вывода ограниченных типов строят индуктивные инварианты функциональных программ высших порядков из инвариантов первого порядка над значениями с закрытыми типами (ground-types). Другими словами, эти фреймворки сводят проблему безопасности программ высшего порядка к проблеме выполнимости дизъюнктов Хорна первого порядка с ограничениями. Для более точного описания этого процесса см.~\cite{cathcart2017higher}.

Тот факт, что получаемые в результате нашей трансляции функции не выше второго порядка, позволяет специализировать и оптимизировать процедуру вывода ограниченных типов. В контексте нашей работы, наиболее интересны композициональные фреймворки вывода ограниченных типов. Примером такого фреймворка является~\cite{zhu2013compositional}. Пример композиционального решателя дизъюнктов Хорна можно найти в~\cite{komuravelli2016smt}.
