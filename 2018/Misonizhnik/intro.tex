\section{Введение}

Хотя объектно-ориентированные языки, такие как \java, C\# или \scala, повсеместно используются в современном программировании, исследование их систем типов всё ещё продолжается. Например, недавно было доказано, что в языке \java отношение подтипирования неразрешимо~\cite{grigore2017java}. В этой работе мы рассмотрим систему типов с нерасширяющимися таблицами классов~\cite{viroli2000recursive}, для которой отношение подтипирования является разрешимым~\cite{kennedy2006decidability}, и которая была адаптирована для реализации наследования в .NET Framework~\cite{ecma2005335}. Наше исследование мотивировано точным межпроцедурным анализом .NET-программ.
Рассмотрим следующий участок кода:
\begin{lstlisting}[basicstyle=\small,numbers=left]
interface (*\icloneable<*)out (*\ttypeparam>*) { (*\ttypeparam*) (*\clonemethod*)(); }
class (*\basetype*) { }
sealed class (*\derivedtype*) : (*\basetype*), (*\icloneable<\derivedtype>*)
{
    public (*\derivedtype*) (*\clonemethod*)() { return new (*\derivedtype*)(); }
}

void (*\texttt{F}<\ttypeparam>*)((*\basetype{}*) (*\texttt{arg1}*), (*\derivedtype*) (*\texttt{arg2}*))
{
    if ((*\texttt{arg2}*) is (*\icloneable<\ttypeparam>*) && (*\texttt{arg1}*) is (*\ttypeparam*))
    {
        var (*\texttt{clone}*) = (((*\derivedtype*)) (*\texttt{arg1}*)).(*\clonemethod*)();(*\label{line:cast-to-derived}*)
        ...
    }
}
\end{lstlisting}
Можно подумать, что выражение преобразования типа (строка~\ref{line:cast-to-derived}) всегда исполняется корректно: \derivedtype{} реализует только интерфейс \icloneable\texttt{<}\derivedtype\texttt{>}, значит \ttypeparam{} может быть только типа \derivedtype{}, поэтому, если строка~\ref{line:cast-to-derived} достижима, то \texttt{arg1} имеет тип \derivedtype. Однако в этих рассуждениях есть ошибка: \icloneable{} является ковариантным конструктором типа, а \basetype{} является надтипом для \derivedtype{}, значит \icloneable\texttt{<}\basetype\texttt{>} является надтипом для \derivedtype{}, и строка~\ref{line:cast-to-derived} достижима при \ttypeparam{} $=$ \basetype{}.

Автоматическая модульная верификация таких программ требует рассуждений о подтипировании между \emph{открытыми} типами (например, такими являются типы со свободными типовыми параметрами). В данном примере кода надо ответить на вопрос <<существуют ли такие типы \ttypeparam{} и \ttypeparam{}$'$, что \derivedtype{} является подтипом для \onector{\icloneable{}}{\ttypeparam{}}, \ttypeparam{}$'$ является подтипом для \basetype{} и \ttypeparam{}, и \ttypeparam{}$'$ не является подтипом \derivedtype{}?>> Этот вопрос можно формально записать в виде формулы логики предикатов
\[
    \begin{array}{l}
    \exists \ttypeparam{}, \ttypeparam{}'.\,\, \derivedtype{}\subtype{}\onector{\icloneable{}}{\ttypeparam{}} \wedge \\ \ttypeparam{}'\subtype{}\basetype{} \wedge \ttypeparam{}'\subtype{}\ttypeparam{} \wedge \ttypeparam{}'\notsubtype{}\derivedtype{}
    \end{array}
\]
Очевидно, эта формула выполнима при $\ttypeparam{}=\ttypeparam{}'=Base$.

В работе формализуется и изучается \emph{задача выполнимости в логике первого порядка} для ограничений номинальной системы типов с вариантностью. Насколько нам известно, это первая попытка детального изучения этой задачи. Мы покажем несколько примеров бескванторных формул первого порядка, которые показывают, что задача выполнимости достаточно сложна даже для нерасширяющегося наследования. Основным результатом работы является доказательство неразрешимости этой задачи. Доказательство использует примечательно маленький фрагмент системы типов. По факту, мы показали, что задача выполнимости ограничений на подтипирование неразрешима для \emph{нерасширяющихся} таблиц классов (1) без контравариантных конструкторов, (2) только с нульарными и унарными конструкторами, (3) для бескванторной конъюнкции атомов подтипирования без отрицаний.

После этого мы расскажем о  практической применимости работы и о направлениях для будущих исследований задачи выполнимости ограничений на подтипирование. Одно из самых амбициозных и нетривиальных направлений для исследования --- это поиск разрешимого, но всё ещё практически применимого фрагмента задачи. Другое --- реализация эффективной разрешающей процедуры.
