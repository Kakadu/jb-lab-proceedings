\renewcommand{\thelstlisting}{%
     \ifnum\value{subsection}=0
       \arabic{lstlisting}%
     \else
       \ifnum\value{subsubsection}=0
         \arabic{lstlisting}%
       \else
         \arabic{lstlisting}%
       \fi
     \fi
}

\lstdefinelanguage{ocaml}{
keywords={ostap, let, begin, end, in, match, type, and, fun,
function, try, with, class, object, method, of, rec, repeat, until,
when, while, not, do, done, as, val, inherit, module, sig, @type, struct,
if, then, else, open, virtual, new, fresh},
sensitive=true,
basicstyle=\normalsize\ttfamily,
commentstyle=\scriptsize\rmfamily,
keywordstyle=\underline,
identifierstyle=\ttfamily,
basewidth={0.5em,0.5em},
columns=fixed,
fontadjust=true,
literate={->}{{$\to$}}3
         {===}{{$\equiv$}}1
}

\lstset{
extendedchars=\true,
basicstyle=\normalsize,
identifierstyle=\ttfamily,
keywordstyle=\bfseries,
commentstyle=\scriptsize\rmfamily,
basewidth={0.5em,0.5em},
fontadjust=true,
frame=single,
numbers=left,
numberstyle=\normalsize,
numbersep=5pt,
captionpos=b,
%escapechar=!,
language=ocaml,
mathescape=true
}

\setlength{\abovedisplayskip}{1pt}
\setlength{\belowdisplayskip}{1pt}

\title{Монадические парсер-комбинаторы с поддержкой симметричной альтерации и левой рекурсии}

\titlerunning{Монадические парсер-комбинаторы}

\author{Боровков Данила Викторович}

\authorrunning{Боровков~Д.~В.}

\tocauthor{Боровков~Д.~В.}
\institute{Санкт-Петербургский государственный университет\\
	\email{danila.borovkov1996@gmail.com}}

\maketitle

\begin{abstract}
  В данной работе описывается модификация монадических парсер-комбинаторов, которая обеспечивает симметричность
  альтерации и поддержку левой рекурсии. Обеспечение этих свойств особенно важно в контексте компонентной разработки
  синтаксических анализаторов. Описаны основные понятия, подходы и проблемы в данной области,
  представлена реализация библиотеки монадических парсер-комбинаторов, поддерживающих левую рекурсию и симметричную альтерацию,
  и приведены результаты как количественной, так и качественной их апробации.
\end{abstract}

\section*{Введение}
В настоящее время трансляция программного кода играет важную роль в сфере программирования. Процесс трансляции заключается в преобразовании кода программы, написанного на языке программирования высокого уровня, в машинный код или в текст на другом языке программирования. Одним из этапов трансляции традиционно является синтаксический анализ, который обычно заключается в проверке соответствия анализируемого текста некоторой грамматике и построении дерева синтаксического анализа. Программное обеспечение, выполняющее синтаксический анализ, называется синтаксическим анализатором или парсером.

Одним из самых простых и удобных подходов к построению синтаксических анализаторов по входной грамматике являются парсер-комбинаторы~\cite{meijer}. Парсер-комбинатор~--- это функция высшего порядка, принимающая парсеры в качестве аргументов, конcтруирующая из них другой парсер и возвращающая его в качестве результата. Во многом этот подход похож на расширенную форму Бэкуса-Наура: парсер-комбинаторы соответствуют примитивам, а элементарные парсеры~--- терминалам. Помимо удобства и простоты преимуществом парсер-комбинаторов является возможность использования для описания анализаторов конструкций языка, на котором ведется разработка, что позволяет, например, создавать анализаторы высшего порядка.

Исследована связь парсер-комбинаторов с таким математическим объектом, как монада~\cite{meijer,wadler}, позволяющим формально представить вычислительный процесс и его побочные эффекты. Было показано, что анализаторы могут быть реализованы в виде монад, что предоставляет возможность построить математическую модель процесса синтаксического анализа. Помимо этого, сами монадические парсер-комбинаторы удобны для использования: например, они позволяют описывать синтаксический анализ контекстно-зависимых языков.

Однако у канонической реализации парсер-комбинаторов имеются существенные трудности, а именно: несимметричность альтерации и левая рекурсия. Несимметричность альтерации (также называемая ``longest match first'') вызвана тем, что при использовании альтернативы анализатор с более длинным результатом должен быть рассмотрен в первую очередь. Если не следовать этой стратегии и составлять альтернативы иным способом, то это приведет к трудно отслеживаемым ошибкам в работе описываемого анализатора. Второй трудностью является левая рекурсия в грамматике анализируемого языка, которая приводит к зацикливанию алгоритмов синтаксического анализа. Поэтому эти алгоритмы предполагают, что грамматика описываемого анализатора будет без леворекурсивных правил. В примитивных случаях оба недостатка возможно нейтрализовать статическим преобразованием входной грамматики: перевести грамматику в форму без леворекурсивных правил и правильно задать порядок альтернативы, однако в случае описания анализаторов высшего порядка при компонентной разработке распознавание левой рекурсии и правильное построение альтерации являются неразрешимыми задачами.

Чувствительность к левой рекурсии и правилу ``longest match first''~--- два фундаментальных недостатка парсер-комбинаторов, устранению которых посвящено множество работ~\cite{frost,tratt,warth}, однако до сих пор никто не справлялся с этими трудностями так успешно как авторы работы~\cite{meerkat}. Было решено расширить подход из этой работы до монадических парсер-комбинаторов. В качестве платформы для разработки новых парсер-комбинаторов была взята библиотека Ostap~\cite{ostap}, в которой ранее использовалась каноническая реализация монадических парсер-комбинаторов. Ostap обеспечивает сборку отдельно компилируемые строго типизированные компоненты, а для удобства использования парсер-комбинаторов библиотека предоставляет предметно-ориентированный язык (далее DSL).
Перейдем к описанию цели и задач данной работы.

\section*{Постановка задачи}

Целью данной работы является доработка библиотеки парсер-комбинаторов Ostap с добавлением возможности использования входных грамматик с леворекурсивными правилами и отказом от ограничения ``longest match first''.

В связи с этим были поставлены следующие задачи:
\begin{itemize}
    \item обзор существующих решений и анализ предметной области;
    \item разработка алгоритма монадических парсер-комбинаторов;
    \item интеграция разработанных парсер-комбинаторов в библиотеку Ostap;
    \item апробация доработанной библиотеки.
\end{itemize}

\section*{Глава 1. Обзор предметной области}

\subsection*{1.1. Монады и парсеры}

Монада~--- это паттерн, позволяющий описывать вычисления, происходящие над выбранным типом данных. Помимо результата вычисления монада позволяет описывать в своей структуре побочные эффекты и контекст вычисления и разделять само вычисление с обработкой побочных эффектов, что повышает композициональность программного кода. Для комбинирования вычислений монада обладает методами \lstinline|result| и \lstinline|bind|. Метод \lstinline|result| позволяет создавать инстанс монады с некоторым начальным контекстом по данным, которые передаются методу result как аргумент. Метод \lstinline|bind| описывает изменение контекста в процессе последовательных вычислений. Однако не каждый объект с такими методами является монадой~--- для этого необходимо удовлетворять условиям, представленными в листинге 1.

\begin{lstlisting}[basicstyle=\small, caption=Законы монады]
   (result a) bind ($\lambda$ n) = n[a/b]
   m bind result = m
   m bind ($\lambda$ a. n bind ($\lambda$ k)) = (m bind ($\lambda$ a. n)) bind ($\lambda$ k)
\end{lstlisting}

В этом примере и далее в этой главе использована лямбда-нотация вида \lstinline|$\lambda$ x. expr| для обозначения лямбда-абстракции над аргументом ``\lstinline|x|'', который свободно содержится в ``\lstinline|expr|''.

Первое условие заключается в том, что применение метода \lstinline|bind| к монаде, полученной с помощью \lstinline|result|, эквивалентно применению функции ``\lstinline|n|'' к аргументу \lstinline|result|. Второе условие показывает, что метод \lstinline|result| является правым нейтральным по отношению к методу \lstinline|bind|. Третье условие показывает, что \lstinline|bind| ассоциативен.

У монады выделяют частный случай, называемый монадой плюс, который предоставляет дополнительные возможности комбинирования монад для описания вычислительного процесса: метод \lstinline|plus|, комбинирующий два инстанса монады в один, и метод \lstinline|zero|, просто возвращающий инстанс монады. Эти два метода должны соответствовать условиям, которые показаны в листинге 2.

\begin{lstlisting}[basicstyle=\small, caption=Законы монады плюс]
   zero plus n = n
   m plus zero = m
   m plus (n plus o) = (m plus n) plus o
   zero bind k = zero
   m bind ($\lambda$ a. zero) = zero
   (m plus n) bind k = (m bind k) plus (n bind k)
\end{lstlisting}

Первые два условия показывают, что \lstinline|zero| нейтрален по отношению к методу \lstinline|plus|.
Третье условие показывает, что \lstinline|plus| ассоциативен.
Четвертое и пятое условие показывает, что результатом \lstinline|bind| является \lstinline|zero|, если его левый аргумент является \lstinline|zero| или если его правый аргумент возвращает \lstinline|zero|.
Шестое условие~--- условие дистрибутивности, которое связывает методы \lstinline|bind| и \lstinline|plus|.

Монады являются очень удобным средством для представления процесса синтаксического анализа~\cite{meijer}, позволяющие не только описывать контекстно-свободные языки, но и рассматривать теоретическую модель процесса. В листинге 3 показано, как анализаторы могут быть реализованы в виде монады.

\begin{lstlisting}[basicstyle=\small, caption=Парсеры как монады]
   type Parser a = String -> [(a,String)]

   result :: a -> Parser a
   result v = $\lambda$ inp. [(v,inp)]

   bind :: Parser a -> (a -> Parser b) -> Parser b
   p bind f = $\lambda$ inp. concat [f v out | (v,out) <- p inp]
\end{lstlisting}

В данном примере представлен анализатор, принимающий на вход строку и возвращающий результат, который является списком пар, где первый элемент~--- это суффикс строки, который еще не удалось проанализировать, а второй элемент~--- это некоторый результат разбора. Для анализатора такого типа в строках 4 и 7 реализованы монадические методы \lstinline|result| и \lstinline|bind|. Эти методы должны удовлетворять законам монады, которые были показаны в листинге 1, что было доказано в работе~\cite{wadler}.

Также анализатор из листинга 3 может быть легко расширен до монады плюс, как показано в листинге 4.

\begin{lstlisting}[basicstyle=\small, caption=Парсеры как монады плюс]
   zero :: Parser a
   zero = $\lambda$ inp. []

   plus :: Parser a -> Parser a -> Parser a
   p plus q = $\lambda$ inp. (p inp ++ q inp)
\end{lstlisting}

Методы \lstinline|zero| и \lstinline|plus| также удовлетворяют монадическим законам~\cite{wadler}, представленным в листинге 2.

Реализованные выше методы \lstinline|plus| и \lstinline|bind|~--- это парсер-комбинаторы \lstinline|alt| и \lstinline|seq| соответственно, имеющие следующий смысл: \lstinline|alt| реализует альтерацию между двумя анализаторами, а \lstinline|seq|~--- последовательный процесс синтаксического анализа с передачей результата первого анализатора второму. В дальнейшем, это передаваемое значение будет называться монадическим. Эти парсер-комбинаторы удобно использовать в связи с аналогичным форматом записи граматик в форме Бэкуса-Наура.

При этом \lstinline|result x|~--- это простейший анализатор, возвращающий ``\lstinline|x|'' в качестве результата, а \lstinline|zero| ~--- это анализатор, всегда выдающий ошибку.

Представление анализаторов в виде монад обладает следующими преимуществами: метод \lstinline|bind| позволяет обойтись без обработки пар из результатов, возникающих в других реализациях последовательного синтаксического анализа, а также такое представление позволяет использовать сокращенный синтаксис записи монад. Дополнительно, в работе~\cite{meijer} монада парсера была представлена в виде композиции монады недетерминизма и монады состояния и при этом простейшие парсер-комбинаторы выражаются через методы этих двух монад. Такое разделение не только упрощает изменение реализации парсера, но и способствует переиспользованию соответствующих компонент.

\subsection*{1.2. Левая рекурсия и правило longest match first}

При использовании парсер-комбинаторов больше всего неприятностей доставляют следующие два аспекта: левая рекурсия и правило ``longest match first''.

Как было сказано ранее несимметричность альтерации заключается в том, что при описании альтерации, то есть при использовании парсер-комбинатора \lstinline|alt|, необходимо в первую очередь рассматривать самую длинную альтернативу из двух. Формально это правило можно описать следующим образом:

\[
\forall\phi\;\psi\;:\; A\rightarrow\phi \wedge B\rightarrow\psi \Rightarrow \forall\omega\ne\epsilon\;:\;\psi\ne\phi\omega
\]

Здесь ``\lstinline|A|'' и ``\lstinline|B|''~--- это два парсера, между которыми происходит альтерация.
Это означает, что ни один из суффиксов разобранных вторым парсером строк не должен быть разобран первым парсером. Тогда альтерация удовлетворяет правилу ``longest match first''.
Рассмотрим пример в листинге 5:

\begin{lstlisting}[basicstyle=\small, caption=``Longest match first'']
   binary[op] : arithm op arithm
   arithm : int | ariphm + arithm | ...
   op : ">=" | ">" | "=" | ...
\end{lstlisting}

В строке 1 показан анализатор бинарных логических операций для чисел, который параметризован анализатором знаков бинарных операций. Этот анализатор в свою очередь реализован в строке 3 и представляется из себя альтернативу между знаками операций. При этом знак ``>='' разбирается перед ``>'' по правилу ``longest match first''. В обратном случае анализ выражения ``a >= b'' будет возвращать ошибку: после разбора первого аргумента ``a'' работу начнет анализатор знаков, который успешно завершит работу разобрав ``>''. Однако остаток строки ``=b'' не может быть разобран анализатором второго аргумента и анализ завершится ошибкой. Казалось бы можно просто размещать анализаторы в правильном порядке, но при реализации параметризованных парсеров невозможно определить какой из параметров разберет больший кусок строки.

Левая рекурсия является классической трудностью описания синтаксических анализаторов. Пусть во входной грамматике анализатора есть леворекурсивное правило \lstinline|P : A -> AS|. При стандартном рекурсивном спуске анализ зациклится в этом месте: внутри вызова для нетерминала А произойдет такой же вызов без сдвига по входной строке. В случае классических парсер-комбинаторов происходит то же самое. Обычно с такой проблемой борются с помощью перевода грамматики в нелеворекурсивную форму, однако в при компонентной разработке парсеров эти методы не сработают~--- в некоторых случая невозможно определить наличие левой рекурсии как показано в листинге 6:

\begin{lstlisting}[basicstyle=\small, caption=Левая рекурсия]
   A[B] : B "a" | "a"
   T : A[T]
\end{lstlisting}

В строке 1 листинга 6 описан анализатор, параметризованный анализатором. В зависимости от значения параметра этот анализатор будет леворекурсивным или нет: в строке 2 представлен леворекурсивный случай, который будет разбирать строки, состоящие из буквы~``a'' различной длины.

\subsection*{1.3. Подходы к мемоизации}
Существует много разных подходов к решению проблем комбинаторного разбора, описанных в предыдущем разделе. Одни из таких подходов, обобщенный левосторонний разбор~\cite{GLLcomb}, позволяет распознавать все контекстно-свободные языки и при этом эти комбинаторы нечувтсвительны к порядку альтерации или левой рекурсии. Однако использование пользовательский семантик или перевод комбинаторов в монадичную форму является открытой проблемой, как и компонентная разработка парсеров.

Еще одним способом решения проблемы чувствительности к левой рекурсии является мемоизация, которая заключается в сохранении результатов выполнения для исключения повторных вызовов. Для реализации парсер-комбинаторов было рассмотрено несколько существующих алгоритмов мемоизации, которые описаны ниже.

В статье~\cite{warth} был описан алгоритм, который заключается в мемоизации состояния синтаксического анализа для каждого нетерминала грамматики анализируемого текста. В статье~\cite{tratt} у данного подхода были выявлены существенные недостатки, связанные с некорректной ассоциативностью в случае праворекурсивных правил. Помимо этого, данный подход использует несимметричную альтерацию, что затрудняет использование этого алгоритма в компонентной разработке .

В статье~\cite{frost} был описан алгоритм мемоизации, которая основана на подсчете количества обращений с дальнейшим ограничением его функцией от длины строки. Однако эта информация не всегда известна статически, что, вместе с не лучшей производительностью, является серьезным недостатком этого алгоритма.

При реализации библиотеки парсер-комбинаторов было решено использовать алгоритм библиотеки парсер-комбинаторов Meerkat~\cite{meerkat}. Он сочетает использование мемоизации и продолжений, но в отличие от~\cite{swierstra2001combinator}, который использует этот же подход, поддерживает левую рекурсию. В основу этой библиотеки лег алгоритм из работы~\cite{memo} реализованный на языке Scala для построения сжатого леса разбора (SPPF, Shared Packed Parse Forest). Эти комбинаторы нечувствительный как к левой рекурсии, так и к несиммметричным альтерациям, но не поддерживают пользовательскую семантику и не являются монадическими.

\subsection*{1.4. Библиотека Ostap}
Ostap~--- это библиотека монадических парсер-комбинаторов, разработанная на языке OCaml. Основной задачей при ее разработке являлось обеспечение возможности сборки парсеров из раздельно компилируемых строго типизированных компонент. Несмотря на то, что парсер-комбинаторы привлекательная и выразительная техника для создания парсеров, она требует большого количества дополнительного программного кода, а пользователю удобнее работать с более классическим представлением грамматик, например, с формой Бэкуса-Наура. Возникает естественная идея о сочетании этих двух подходов, которая была реализована в DSL для программирования парсеров, реализованного как синтаксическое расширение языка OCaml с помощью препроцессора Camlp5. Парсер-комбинаторы полностью абстрагированы от семантики разбора: пользователь может строить любое синтаксическое дерево, а также абстрагировано от входной последовательности лексем: в библиотеке используется объектно-ориентированное представление входного потока: пользователь имеет возможность реализовать необходимые методы для лексического анализа в потомке и использовать лексемы с именами новых методов при описании анализаторов. В листинге 7 можно увидеть на примере какие синтаксические конструкции предоставляет DSL библиотеки Ostap для описания анализаторов.

\begin{lstlisting}[basicstyle=\small, caption=Парсеры в синтаксисе Ostap]
  ostap (
    primary: c:IDENT {`Var c};

    exp[primary]:
        e:exp[primary] -"+" p:primary {`Add (e, p)}
      | primary;

    main: exp[primary] -EOF
  )
\end{lstlisting}

Во-первых, рассмотрим конструкции \lstinline|IDENT| и \lstinline|EOF| в строках 2 и 8 соответственно. Для корректной интерпретации пользователь должен реализовать методы \lstinline|getIDENT| и \lstinline|getEOF| для объекта входного потока, и при трансляции соответствующих конструкций будут вызваны эти методы. Строковые литералы также скрывают за собой вызов метода для разбора этой строки.

Во-вторых, в фигурных скобках пользователь может описать действия, строящие дерево разбора, семантику. При этом есть возможность использовать результаты каждого шага с помощью переменных, которые вводятся с помощью двоеточия перед конструкцией анализатора, результат которого необходимо положить в эту переменную.

В-третьих, рассмотрим конструкции DSL Ostap, использованные выше для описания анализаторов. Вертикальная черта в строке 6 соответствует парсер-комбинатору \lstinline|alt|, последовательная запись анализаторов в строке 5 интрепретируется как \lstinline|seq|. Описание остальных парсер-комбинаторов и синтаксиса DSL для их краткой записи можно посмотреть в~\cite{ostap}.

В-четвертых, в этом примере показано, как реализовать параметризованный анализатор: ``\lstinline|exp|'' параметризован парсером, разбирающим один элемент суммы. Тип параметра может быть любым, а не только парсером.

В-пятых, рассмотрим конструкцию \lstinline|ostap ( expr )|. Она используется для обозначения того, что для описания выражения ``\lstinline|expr|'' внутри скобок использован синтаксис DSL Ostap.

Библиотека Ostap была использована для реализации компилятора с семейства обероноподобных языков~\cite{boulytchev2015combinators}; при этом, действительно, готовые анализаторы собирались из прекомпилированных компонент.

\section*{Глава 2. Монадические парсер-комбинаторы}

В рамках данной работы были разработаны парсер-комбинаторы, использующие подход из статьи~\cite{meerkat}. С одной стороны, подход необходимо было адаптировать для монадических парсер-комбинаторов библиотеки Ostap, позволяющих использовать пользовательскую семантику. С другой стороны, библиотека Ostap была написана в direct style, поэтому необходимо было переписать ключевые части библиотеки в стиль передачи продолжений.  В первом разделе будет описан тип для парсера. Во втором разделе будут описаны основообразующие парсер-комбинаторы библиотеки Ostap: \lstinline|seq| и \lstinline|alt|. В третьем разделе будет уделено внимание парсер-комбинатору many, реализация которого также потребовала существенных усилий.

\subsection*{2.1. Описание типа}

В первую очередь был выведен следующий тип продолжений, показанный в листинге 8 вместе с типом самих парсеров.

\begin{lstlisting}[basicstyle=\small, caption=Тип парсера и продолжения]
   type ($\alpha$, $\beta$, $\gamma$, $\sigma$) parser  = $\sigma$ -> ($\alpha$, $\beta$, $\gamma$, $\sigma$) k -> ($\beta$, $\gamma$, $\sigma$) result

   type ($\alpha$, $\beta$, $\gamma$, $\sigma$) k = $\alpha$ -> $\sigma$ -> ($\beta$, $\gamma$, $\sigma$) result

   type ($\sigma$, $\alpha$, $\beta$) result =
     Parsed of ($\alpha$ * $\sigma$) * $\beta$ option
   | Failed of $\beta$ option
   | Empty
\end{lstlisting}

Тип парсера, представленный в строке 1, параметризован четырьмя типами: $\alpha$~--- это тип монадического значения, которое передается этим парсером продолжению, $\beta$~--- это тип пользовательской семантики, $\gamma$~--- это тип возможной ошибки и $\sigma$~--- это тип входной последовательности, которую принимает этот парсер. Парсер принимает продолжение и строку как аргументы и возвращает результат с типом \lstinline|result|, который представлен в 5 строке.

В строке 3 описан тип продолжения, который параметризован так же, как и тип парсера. Продолжение принимает монадическое значение и остаток строки как аргументы и возвращает результат вычислений, которые представлены в этом продолжении.

В строке 5 описан результат работы парсера. \lstinline|Parsed| означает успешный результат анализа и содержит некоторую информацию, полученную в процессе
анализа, и возможную информацию об ошибке. \lstinline|Failed| означает неудачу и содержит возможную информацию об ошибке. \lstinline|Empty| означает, что ничего не произошло, парсер не был запущен.

\subsection*{2.2. Реализация основных парсер-комбинаторов}

При определении типов мы отталкивались от реализации парсер-комбинатора \lstinline|seq|, потому что именно в нем выражается монадичность парсеров и наиболее явно используются продолжения. Реализация \lstinline|seq| в библиотеке Meerkat предполагает передачу второго парсера в качества аргумента первому:

\begin{lstlisting}[basicstyle=\small, numbers=none]
   fun x y s k -> x s (kmemo (fun s' -> y s' k))
\end{lstlisting}

Здесь ``\lstinline|x|'' и ``\lstinline|y|''~--- парсеры, выступающие в качестве аргументов \lstinline|seq|, ``\lstinline|s|''~--- входной поток, ``\lstinline|k|''~--- продолжение, \lstinline|kmemo|~--- примитив мемоизации, к которому вернемся позднее.

В случае монадических парсер-комбинаторов первый парсер-аргумент должен передавать второму свой результат с помощью монадического значения. Так как передача управления в комбинаторе \lstinline|seq| от одного парсера-аргумента к другому происходит посредством вызова продолжения, то при этом вызове необходимо передавать и монадическое значение. Поэтому для продолжений был добавлен еще один аргумент~--- монадическое значение ``\lstinline|a|'' (тип $\alpha$ в предыдущем разделе), и комбинатор \lstinline|seq| приобрел следующий вид:

\begin{lstlisting}[basicstyle=\small, numbers=none]
   fun x y s k -> x s (kmemo (fun a s' -> y a s' k))
\end{lstlisting}

Здесь аргумент ``\lstinline|х|''~--- это также парсер, который запустится первым, а ``\lstinline|y|''~--- это функция, которая примет монадическое значение первого парсера и вернет парсер, который запустится на остатке входного потока.

Перейдем теперь к реализации парсер-комбинатора \lstinline|alt|.

\begin{lstlisting}[basicstyle=\small, numbers=none]
   fun x y -> memo (fun s k -> (x s k) <@> (y s k))
\end{lstlisting}

Этот парсер-комбинатор принимает на вход два парсера ``\lstinline|x|'' и ``\lstinline|y|'', одинакового типа. Из них конструируется парсер, который принимает на вход строку ``\lstinline|s|'' и продолжение ``\lstinline|k|'' и запускает на них парсеры. После этого результаты суммируются с помощью функции суммирования результатов \lstinline|<@>| и сумма возвращается в качестве результата. Этот парсер мемоизируется с помощью функции \lstinline|memo|, и возвращается в качестве результата парсера \lstinline|alt x y|.

\subsection*{2.3. Мемоизация монадических парсер-комбинаторов}

Алгоритм мемоизации в библиотеке Meerkat использует три функции: \lstinline|kmemo|, \lstinline|memo| и \lstinline|memoresult|. Адаптированный для библиотеки Ostap вариант этого алгоритма выражен тоже в трех функциях, работу которых сейчас будет разобрана поподробнее.

Раюоты функция kmemo, использованной в листингах 8 и 9 заключается в мемоизации продолжений~--- внутри неё создается таблица, в которой сохраняются вызовы продолжения на разных аргументах. Таким образом эта функция обеспечивает единственность вызова каждого продолжения на каждом агументе.

Как было показано в листинге 10 парсер-комбинатор \lstinline|alt| использует функцию \lstinline|memo| для мемоизации. Рассмотрим теперь в чем заключается ее суть. Эта функция принимает парсер в качестве аргумента и возвращает парсер, но уже мемоизированный. В теле этой функции создается таблица, которая хранит частично примененные ко входному потоку парсеры, на которых была вызвана функция \lstinline|memoresult|. Такая таблица обеспечивает то, что парсер-аргумент будет обработан лишь однажды для каждого входного потока, а значит бесконечный цикл невозможен. Реализация этой функции также не претерпела существенных изменений по сравнению с библиотекой Meerkat, поэтому сосредоточимся на реализации функции \lstinline|memoresult|.

\begin{lstlisting}[basicstyle=\small, caption=Алгоритм мемоизации]
  let memoresult = fun p ->
    let ss : ('stream * 'a) list ref = ref      [] in
    let ks :                K.ks ref = ref K.empty in
    fun k ->
      if $\mbox{это первый запуск p}$
      then (
        ks := K.singleton k;
        p (fun a s ->
            $\mbox{если (s, a) не было в ss}$
            $\mbox{записываем ее в ss и}$
            $\mbox{запускаем на ней все продолжения из ks}$
            $\mbox{иначе возвращаем Empty}$
          )
      )
      else (
        ks := K.add k !ks;
        $\mbox{запустить k на всех сохраненных в ss парах}$
      )
\end{lstlisting}

Следует отметить, что в данном случае \lstinline|p|~--- это не парсер, а частично примененный ко входному потоку парсер.

В этой функции заключена основная часть алгоритма мемоизации. В строках 2 и 3 создаются два списка: \lstinline|ks| для сохранения продолжений, которые были переданы частично примененному парсеру \lstinline|p|, и \lstinline|ss| для хранения аргументов, которые были переданы \lstinline|р| продолжениям. В дальнейшем при каждом вызове частично примененног парсера \lstinline|p| на продолжении вместо собственно вызова \lstinline|p| будет происходить вызов продолжения на все элементах \lstinline|ss|. А при появлении новых аргументов при вызове продолжения будет происходить вызов всех продолжений из списка \lstinline|ks| на этих аргументах. Можно заметить, что \lstinline|р| вызывается в строке 8 и за счет условия в строке 5 это происходит лишь однажды. Таким образом, функция \lstinline|memoresult| обеспечивает, что вызов частично примененного парсера \lstinline|р| будет произведен единожды и все переданные ему продолжения будут вызваны на всех парах из монадического значения и остатка входного потока, которые \lstinline|р| передавал продолжениям.

В строке 12 возвращается результат \lstinline|Empty| потому что в этой ветке условного оператора просто не происходит никакого вызова, а значит нет никакого результат. Было бы некорректно возвращать ошибку, поэтому был добавлен третий вариант результата, помимо \lstinline|Parsed| и \lstinline|Failed|

В алгоритме библиотеки Meerkat \lstinline|ss|~--- это список входных потоков, однако в нашем случае, монадическом, это необходимо было изменить. Теперь у продолжения два аргумента: помимо входного потока передается и монадическое значение. Поэтому \lstinline|ss| теперь хранит пары из монадического значения и входного потока.

Для правильного сравнения продолжений между собой необходимо использовать модуль \lstinline|Obj| и функцию неконтролируемого преобразования типов \lstinline|Obj.magic|. Для того, чтобы инкапсулировать использование небезопасных примитивов был создан модуль \lstinline|K|, который описывает хранилище продолжений \lstinline|K.ks| и интерфейс работы с ним. В строках 3, 7 и 16 листинга .. можно увидеть использование некоторых из этих методов.

\subsection*{2.4. Парсер-комбинатор many}

В листинге 10 представлена реализация еще одного парсер-комбинатора~--- комбинатора \lstinline|many|, работа которого заключается в повторном применении парсера-аргумента.

\begin{lstlisting}[basicstyle=\small, caption=Парсер-комбинатор many]
   let rec many p s k =
     let result = ref (k [] s) in
       let rec loop alist stream =
         p stream (fun a stream' ->
                   let newalist = alist @ [a] in
                   let curResult = k (newalist) stream' in
                   result := curResult <@> !result;
                   let _ = loop (newalist) stream' in
                   curResult)
       in
       let _ = loop [] s in
       !result
\end{lstlisting}

Как и в предыдущих листингах ``\lstinline|s|'' и ``\lstinline|k|'' в строке 1~--- это аргументы парсера, сконструированного с помощью парсер-комбинатора \lstinline|many|. В строке 2 создается ссылка на результат, с помощью которой будет производиться суммирование результатов каждого кратного применения парсера ``\lstinline|р|'' для дальшейшей передачи суммы результатов как результата парсера \lstinline|many p|. Начальное значение задается как результат нуля последовательных применений парсера ``\lstinline|р|'', то есть как незамедлительный вызов продолжения на пустом списке монадических значений, потому что ``\lstinline|р|'' не вызывался ни разу, и на строке ``\lstinline|s|'', потому что ничего не было проанализировано.

В строке 3 задается итеративный процесс повторных запусков парсера ``\lstinline|р|''. Текущая итерация получается информацию о предудущих запусках парсера ``\lstinline|р|'' посредством двух аргументов: ``\lstinline|alist|''~--- список монадических значений, переданных предыдущими запусками парсера ``\lstinline|p|'', и ``\lstinline|stream|''~--- остатком строки после предыдущих запусков ``\lstinline|p|''. Единственное действие, которое совершает цикл на каждой итерации~--- это запуск парсера ``\lstinline|р|'' на остатке строки ``\lstinline|stream|'' и на продолжении ``\lstinline|k|''.

В строке 4 продолжение принимает два аргумента: ``\lstinline|a|'' и ``\lstinline|stream' |''~--- это монадическое значение, переданное парсером ``\lstinline|р|'' и остаток строки после его работы соответственно. В строке 5 список монадических значений пополняется новым. В строке 6 происходит запуск продолжения ``\lstinline|k|'' из строки 1 на новом списке и текущем остатке строки и таким образом происходит окончание . Результат этого запуска суммируется с результатом всех предыдущих кратных запусков. Далее, в строке 7 происходит переход на следующую итерацию с новым остатком строки и обновленным списком монадических  значений.

В строке 11 происходит запуск цикла на начальных данных, коими являются пустой список для списка монадческих значений и вся строка. В строке 12 в качестве результата \lstinline|many p| возвращается сумма результатов кратных запусков парсера ``\lstinline|р|'', которая строилась в ходе цикла.

\section*{Глава 3. Интеграция в библиотеку Ostap}
Парсер-комбинаторы, описанные в предыдущей главе, имеют тот же интерфейс, что и парсер-комбинаторы из библиотеки Ostap, кроме дополнительного аргумента у парсера~--- продолжения. Таким образом, получилось заменить только реализацию парсер-комбинаторов, а программный код расширения, который их использует, изменять практически не пришлось.

Однако, для корректной работы парсер-комбинаторов изменения в коде расширения были необходимы.

\subsection*{3.1. Комбинатор неподвижной точки}
Для правильной мемоизации необходимо было использовать комбинатор неподвижной точки. С его помощью при рекурсивном вызове парсера мемоизирующие таблицы будут одни и те же и не будут создаваться заново при каждом вызове. Поэтому было решено при интерпретации каждой конструкции \lstinline|ostap ( ... )|, показанной в листинге 7, генерировать комбинатор неподвижной точки, принимающий на вход n аргументов, где n~--- количество парсеров, определяемых внутри конструкции, и возвращающий n-местный кортеж с парсерами, избавленными от рекурсивных вызовов. Для примера из листинга 7 будет сгенерирован комбинатор неподвижной точки с 3 аргументами и возвращающий тройку парсеров.

Для того, чтобы при запуске комбинатора неподвижной точки получились парсеры, избавленные от рекурсивных вызовов, в качестве аргументов ему должны быть переданы функции, которые реализованы так же как описываемые парсеры, но в которых рекурсивные вызовы заменены на вызов аргументов. В листинге 11 показана такая функция для парсера ``\lstinline|exp|'' из листинга 7.

\begin{lstlisting}[basicstyle=\small, caption=Парсеры без рекурсивных вызовов]
let exp' [primary] =
  fun exp primary main ->
      e:exp[primary] -"+" p:primary {`E2 (e, p)}
    | p:primary {`E1 p}
\end{lstlisting}

Для наглядности было решено не переписывать тело парсера в чистый OCaml, а оставить как в листинге 7. Такую функцию легко сгенерировать, зная имена определяемых парсеров и тело самого парсера. В данном примере у функции ``\lstinline|exp' |'' помимо самого exp добавлены аргументы ``\lstinline|main|'' и ``\lstinline|primary|'', потому что они так же описаны внутри конструкции \lstinline|ostap ( ... )| в листинге 7 и могут быть вызваны в теле парсера ``\lstinline|exp|'', что может привести к рекурсивному вызову парсеров ``\lstinline|main|'' и ``\lstinline|primary|''.

Как было сказано выше, для каждой конструкции \lstinline|ostap ( ... )| генерируется свой комбинатор неподвижной точки с необходимым количеством аргументов. Классическая реализация комбинатора была обобщена на несколько аргументов. В листинге 12 показано, что будет сгенерировано для кода из листинга 7.

\begin{lstlisting}[basicstyle=\small, caption=Код комбинатора неподвижной точки]
   let (primary, exp, main) =
     let generated_fixpoint f g h = ... in
     $\mbox{\{*парсеры, избавленные от рекурсивных вызовов*\}}$
     let primary' = ..
     and exp' primary = ..
     and main' = ..
     in generated_fixpoint primary' exp' main'
\end{lstlisting}

Однако такого  комбинатора неподвижной точки не хватает для корректной работы парсер-комбинаторов. Проблема возникает при использовании параметризованных парсеров, например ``\lstinline|exp|''. Дело в том, что необходимо убедиться в том, что при передаче парсеру ``\lstinline|exp|'' одного и того же параметра не будет происходить создания новых мемоизационных таблиц. Для этого было решено производить мемоизацию по параметрам внутри комбинатора неподвижной точки: дополнительно генерируется код для создания мемозацинной таблицы и при передаче парсеру параметров сначала происходит поиск в таблице по кортежу из парметров. В ячейках таблицы записывается результат вызова освобожденных от рекурсивных вызовов функций ``\lstinline|f|'', ``\lstinline|g|'' и ``\lstinline|h|'' из строки 2, и, если вызов уже происходил, результат берется из таблицы.

С добавлением такой мемоизации получается, что генерируется комбинатор неподвижной точки, который учитывает не только количество определяемых парсеров в рамках данной конструкции \lstinline|ostap ( ... )|, но и количество параметров у каждой из них.

\subsection*{3.2. Явно полиморфные типы}

Интерпретация таких конструкций как \lstinline|CONST| также претерпела некоторые изменения. Как уже говорилось ранее, строки символов в высшем регистре интерпретируются как вызов метода входного потока, то есть для правильной работы такого парсера ему необходимо передавать как аргумент объект входного потока, имеющий метод \lstinline|getCONST|. Из-за того, что реализация использует стиль передачи продолжений, для описания типов методов были использованы явно полиморфные типы. Однако, в таком случае, при вызове метода \lstinline|getCONST| у входного потока необходимо явно указывать тип и в нем полиморфный тип у соответствующего метода. В листинге 13 показано, что именно генерируется для решения описанной выше проблемы.

\begin{lstlisting}[basicstyle=\small, caption=Генерируемый код для конструкции CONST]
< getCONST :
   $\beta$ . ($\alpha$ -> 'self -> ('self, $\beta$, $\gamma$) result) ->
             ('self, $\beta$, $\gamma$) result;
  .. >
\end{lstlisting}

В данном примере метод \lstinline|getCONST| явно полиморфен по переменной $\beta$~--- типу пользовательской семантики. В отличие от переменной $\alpha$, которая оставлена свободной с типом пользовательской семантики так же поступить нельзя из-за того, что значение $\alpha$ определится в реализации метода, а значение $\beta$ зависит от продолжения, которое будет передано этому методу, поэтому статически ее значение определить невозможно. Помимо явного указания типов при вызове методов, это также необходимо делать при реализации методов при описании обхекта входного потока.

Интерпретация остальных конструкций синтаксиса предметно-ориентированного языка библиотеки Ostap существенным образом не менялась.

\section*{Глава 4. Тестирование и апробация}

\subsection*{4.1. Тестирование}
Цель данного тестирования заключается в том, чтобы убедиться в работоспособности новой версии библиотеки Ostap на примерах как с леворекурсивными правилами вывода, так и без. Также было решено произвести сравнение с предыдущей версией библиотеки, однако при этом допускается ухудшение производительности, потому что в новой версии, в отличие от предыдущей, поддержаны грамматики с левой рекурсией, а так же допущено отступление от стратегии ``longest match first''.

В первую очередь было решено провести тестирование корректности и работоспособности новой версии библиотеки на тестах библиотеки Ostap. Во-первых, было произведено тестирование лексических конструкций таких как \lstinline|IDENT| и \lstinline|EOF|, описанных ранее в этой работе, и парсер-комбинаторов  \lstinline|alt| и  \lstinline|seq|.

Во-вторых, было произведено тестирование конструкций для построения синтаксического дерева и использования переменных для обращения промежуточным результатам. Далее было произведено тестирование парсер-комбинатора \lstinline|many|, параметризованных парсеров, а также определения нескольких парсеров в рамках одной конструкции \lstinline|ostap ( ... )|.

В-третьих, было произведено тестирование использования программного кода языка Ocaml, модулей и классов при описании парсеров. Затем были протестированы парсеры для контекстно-зависимых языков и использование условий при описании парсеров. После этого было произведено тестирование для парсеров с левой рекурсией и нарушением стратегии ``longest match first''.

Сравнение новой версии библиотеки Ostap со старой было произведено уже в рамках апробации.

\subsection{Апробация}
Для апробации было решено использовать новую версию библиотеки Ostap для синтаксического анализатора учебного языка, используемого в курсе
компиляторов\footnote{https://compscicenter.ru/courses/compilers/2018-spring}. Стоит обратить внимание на то, что это компилятор, собранный с новой версией библиотеки Ostap прошел регрессионные тесты. Таким образом подтверждается, что регресса не произошло при переходе на новую версию.

\subsection{Нечувствительность с правилу ``longest match first''}

В эталонном компиляторе, упомянутом выше, есть фрагмент, который хорошо иллюстрирует возникновение труднообнаружимых отложенных ошибок при нарушении порядка альтерации:

\begin{lstlisting}[basicstyle=\small]
  Ostap.Util.expr [|
    `Lefta, [$\verb/"!!"/$];
    `Lefta, [$\verb/"&&"/$];
    `Nona , [$\verb/"=="/$; $\verb/"!="/$; $\verb/"<="/$; $\verb/"<"/$; $\verb/">="/$; $\verb/">"/$];
    `Lefta, [$\verb/"++"/$; $\verb/"+"/$; $\verb/"-"/$];
    `Lefta, [$\verb/"*"/$; $\verb/"//"$; $\verb/"%"/$] |]
\end{lstlisting}

В данном фрагменте используется парсер высшего порядка \lstinline|Ostap.Util.expr|, который позволяет описывать выражения с бинарными операциями разного старшинства и ассоциативности с помощью простых конструкций. Эти конструкции помимо большого количества кода также скрывают от пользователя использование альтерации, поэтому пользователь должен следовать принципу ``longest match first'' не используя альтерацию явным образом: в строке 4 знаки ``>='' и ``>'' должны следовать именно в таком порядке.

Для проверки нечувствительности новых парсер-комбинаторов библиоткеи Ostap к порядку альтерации в строке 4 знаки ``>'' и ``>='' были переставлены. Это изменение не повлекло за собой не только ошибки, но и ухудшения производительности.

\subsection{Использование леворекурсивных описаний}

Еще одним интересным местом реализации парсера эталонного компилятора является описание оператора ``;'':

\begin{lstlisting}[basicstyle=\small]
  parse:
        s:stmt ";" ss:parse {Seq (s, ss)}
      | stmt;
\end{lstlisting}

В данном фрагменте описан парсер \lstinline|parse|, который описывает последовательность \lstinline|stmt| разделенную знаками ``;''. Этот парсер раньше необходимо было описывать именно таким, нелеворекурсивным способом, а следующая реализация не работала:

\begin{lstlisting}[basicstyle=\small]
  parse:
        ss:parse ";" s:stmt {Seq (ss, s)}
      | stmt;
\end{lstlisting}

Видно, что при вызове парсера \lstinline|parse| сразу же произойдет повторный вызов того же парсера, значит это описание леворекурсивно.

Для проверки новой версии были использовано второе описание парсера \lstinline|parse|, и при этом  парсер эталонного компилятора остался работоспособным и время его работы не изменилось.

Результаты апробации показаны в таблице ниже. Видно, что парсеры, написанные с помощью новой версии библиотеки, работают в несколько раз быстрее по сравнению со старой версией. В первом столбце показан размер выражения (число знаков бинарных операций), а в двух других представлено время работы в секундах парсера эталонного компилятора, собранного с помощью старой версии библиотеки, и того же парсера, собранного с помощью новой версии.

\subsection{Повышение производительности}

Для измерения производительности новой и предыдущей версии библиотеки Ostap тоже был использован эталонный компилятор. В качестве тестового набора использовались программы вида ``\lstinline|x1 := {expr}|'' для разной длины выражения \lstinline|expr|. Изначально тестовый набор содержал и программы вида ``\lstinline|x1 := {expr}; ... xn := {expr}|'', однако было замечена прямо пропорциональная зависимость времени работы от количества выражений, и поэтому тестовый набор был сужен без потери репрезентативности. Однако запуск на этих тестах выявил интересную особенность новой реализации библиотеки Ostap: из-за того, что теперь в парсер-комбинаторе \lstinline|seq| второй парсер запускается в продолжении, глубина рекурсивных вызовов существенно растет при увеличении количества присваиваний. В старой версии такого не наблюдается, поэтому теперь следует внимательно относиться к конфигурации среды времени исполнения для выделения достаточного количества памяти под стек.

Результаты апробации показаны в таблице ниже. Видно, что парсеры, написанные с помощью новой версии библиотеки, работают в несколько раз быстрее по сравнению со старой версией. В первом столбце показан размер выражения (число знаков бинарных операций), а в двух других представлено время работы в секундах парсера эталонного компилятора, собранного с помощью старой версии библиотеки, и того же парсера, собранного с помощью новой версии.

\begin{table}[htbp]
\begin{center}
\begin{tabular}{|c|c|c|}
\hline
\textbf{Размер} & \multicolumn{2}{|c|}{\textbf{Время разбора, cек.}} \\
\cline{2-3}
\textbf{примера} & \textbf{Старая версия} & \textbf{Новая версия} \\
\hline
100& 0,25& 0,13 \\
\hline
200& 0,52& 0,24 \\
\hline
400& 2,13& 0,56 \\
\hline
800& 9,19& 1,97 \\
\hline
1200& 21,93& 4,61 \\
\hline
1600& 42,65& 9,50 \\
\hline
\end{tabular}
\vskip3mm
%\caption{Результаты сравнения производительности старой и новой реализаций библиотеки}
\label{tab1}
\end{center}\vspace{-10mm}
\end{table}


\section*{Заключение}

В рамках данной работы были выполнены следующие задачи:
\begin{itemize}
    \item был выполнен обзор следующих реализаций парсер-комбинаторов: алгоритма Warth~\cite{warth}, алгоритма Frost~\cite{frost} и алгоритма Meerkat~\cite{meerkat}; был выбран подход, разработанный в рамках библиотеки Meerkat;
    \item разработан алгоритм монадических парсер-комбинаторов, основанный на выбранном подходе;
    \item выбранный подход был адаптирован для монадических парсер-комбинаторов и на его основе был реализован прототип библиотеки парсер-комбинаторов;
    \item произведена интеграция реализованных парсер-комбинаторов в библиотеку Ostap;
    \item проведена апробация библиотеки и проведено сравнение эффективности с аналогами.
\end{itemize}

\begin{thebibliography}{99}
	\bibitem{meerkat} A. Izmaylova, A. Afroozeh, and T. van der Storm T. Practical, General Parser Combinators // PEPM '16 Proceedings of the 2016 ACM SIGPLAN Workshop on Partial Evaluation and Program Manipulation, pp. 1--12, 2016.
	\bibitem{ostap} D. Boulytchev. Ostap: Parser Combinator Library and Syntax Extension for Objective Caml, 2009.
	\bibitem{boulytchev2015combinators} D. Boulytchev. Combinators and Type-Driven Transformers in objective caml // Science of Computer Programming, Vol. 114, Elsevier, pp. 57--73, 2015.
	\bibitem{meijer} G. Hutton and E. Meijer. Monadic Parser Combinators // Technical Report NOTTCS-TR-96-4, Department of Computer Science, University of Nottingham, 1996.
	\bibitem{wadler} Ph. Wadler. Monads for functional programming // Proc. Marktoberdorf Summer school on program design calculi, 1992.
	\bibitem{tratt} L. Tratt. Direct Left-Recursive Parsing Expression Grammars // Technical Report EIS-10-01, Middlesex University, 2010.
	\bibitem{frost} R. A. Frost, R. Hafiz, and P. Callaghan. Parser Combinators for Ambiguous Left-Recursive Grammars // Practical Aspects of Declarative Languages, PADL’08, 2008.
	\bibitem{warth} A. Warth, J. R. Douglass, and T. Millstein. Packrat Parsers Can Support Left Recursion // Partial Evaluation and Semantics-based Program Manipulation, PEPM ’08, pp. 103--110, 2016.
	% \bibitem{ford2002packrat} B. Ford. Packrat parsing: simple, powerful, lazy, linear time, functional pearl // ACM SIGPLAN Notices, Vol. 37, No. 9, ACM, 2002.
	% \bibitem{ford2004parsing} B. Ford. Parsing expression grammars: a recognition-based syntactic foundation // ACM SIGPLAN Notices, Vol. 39, No. 1, ACM, 2004.
	\bibitem{swierstra2001combinator} S. D. Swierstra. Combinator parsers: From toys to tools // Electronic Notes in Theoretical Computer Science, Vol. 41, No. 1, Elsevier, pp. 38--59, 2001.
	% %\bibitem{knuth1968semantics} D. E. Knuth. Semantics of context-free languages // Mathematical systems theory, Vol. 2, No. 2, Springer, pp. 127--145, 1968.
	% \bibitem{earleycomb} D. Peake, Sean Seefried. A Combinator Parser for Earley's Algorithm, 2004.
	\bibitem{GLLcomb} D. Spiewak. Generalized Parser Combinators, 2010.
	\bibitem{memo} M. Johnson. Memoization in Top-down Parsing // Comput. Linguist., Vol.~21, No~3, 1995.
	% \bibitem{leftcorner} A.Baars, D.Swierstra, M.Viera, Marcos. Typed Transformations of Typed Grammars: The Left Corner Transform // Electronic Notes in Theoretical Computer Science, Vol.~253, No~7, 2010.
\end{thebibliography}
