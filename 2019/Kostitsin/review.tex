\section{Обзор}

% ------------- Обзор предметной области ---------------

\subsection{Символьное исполнение}\label{symbolicExec}
\emph{Символьное исполнение}~--- техника, которая позволяет исполнять программный код в условиях неопределённости входных данных, исследуя все ветки выполнения программы. При конкретном исполнении функции из \autoref{example3}, условие $(\texttt{x} > \texttt{y})$ будет либо ложным, либо истинным, следовательно будет выполнена только одна ветка. При символьном исполнении этой функции входные данные (т. е. \texttt{x} и \texttt{y}) будут заменены на \emph{символы}~--- абстракции над конкретными значениями, при этом обе эти ветки будут исполнены, а результат исполнения каждой ветки будет защищен соответствующим условием попадания в неё. Такое условие будем называть \emph{условием пути}.

Условие пути является одним из элементов состояния интерпретатора, в которое также входит и \emph{символьная память}~--- представление состояния памяти при символьном исполнении. В начале исследования функции условие пути равно \texttt{true}. При встрече ветвления текущая ветка исполнения разбивается на две, условия пути которых равны условиям попадания в ветку \texttt{then} и \texttt{else} соответственно.

\begin{listing}[H]
\begin{lstlisting}[language=csharp]
public static int MaxInt(int x, int y) {
    int maxInt = 0;
    if (x > y) {
        maxInt = x;
    }
    else {
        maxInt = y;
    }
    return maxInt;
}
\end{lstlisting}
\caption{Пример функции для символьного исполнения}
\label{example3}
\end{listing}

Одним из видов символьного исполнения является \emph{статическое символьное исполнение}, результатом которого является значение, которое вернула функция, а также состояние символьной памяти. Главной особенностью данного вида является \emph{слияние} результатов исполнения веток, полученных разветвлении одной ветки. После слияния получается результат исполнения (т. е. значение и символьная память), вбирающий в себя все изначальные ветки, полученный благодаря введению новых синтаксических конструкций, например $ite(condition, thenTerm, elseTerm)$. Результатом исполнения функции из примера в таком случае будет значение $ite(\texttt{X} > \texttt{Y}, \texttt{X}, \texttt{Y})$ и символьная память $M=\{ \texttt{x}\mapsto \texttt{X}, \texttt{y}\mapsto \texttt{Y}, \texttt{maxInt}\mapsto ite(\texttt{X} > \texttt{Y}, \texttt{X}, \texttt{Y}) \}$, где \texttt{X} и \texttt{Y} являются символьными значениями переменных \texttt{x} и \texttt{y} соответственно. 

Для назначения входным данным символьных значений может использоваться метод \emph{ленивой инстанциации}~\cite{khurshid2003generalized} (англ. lazy instantiation). Главная идея данного метода заключается в инициализации данных по необходимости, т. е. вначале символьного исполнения функции все входные данные помечаются как неинициализированные. При первом использовании таких данных происходит их инициализация. Если инициализируется переменная ссылочного типа, то в неё недетерминированно помещаются: значение \texttt{null}, ссылка на новый объект с неинициализированными полями, ссылка на ранее созданный объект. В случае инициализации переменной простого типа, в неё помещается символьное значение соответствующего ей типа. В данном методе во время инициализации значений используется условие пути для проверки, что полученное значение может находиться в данной переменной. Благодаря такому подходу возможно символьное исполнение в условиях отсутствия знаний о некоторых простых ссылочных локациях (т. е. ссылочных локациях у которых известное количество полей). В частности, это позволяет исследовать функции с некоторыми рекурсивными структурами данных без указания априорных ограничений на их размер.

Одним из главных минусов техники символьного исполнения является \emph{взрыв путей исполнения}, т. е. экспоненциальный рост количества исследуемых веток. Важно отметить, что некоторые из этих веток могут быть недостижимы, условия пути в таких ветках будут невыполнимыми.

Для проверки достижимости веток выполнения современные верификаторы~\cite{sethu2018systems, yoshida2017klover, sharma2018veritesting} используют SMT-решатели, которые могут проверять, выполнима ли формула пути определённой ветки: если нет, то исполнение такой ветки прекращается.

\subsection{SMT-решатели}\label{smt}

SMT-решатели~\cite{de2008z3, barrett2011cvc4} являются инструментами для автоматизированной проверки выполнимости логических формул в теориях. На вход эти инструменты принимают формулу логики первого порядка с функциональными, предикатными и константными символами из сигнатуры заранее заданных теорий. Если формула выполнима, то в качестве результата решатель возвращает \texttt{SAT}\footnote{Выполнима (англ. satisfiable)} и модель, которая интерпретирует формулу истинно. Если формула невыполнима, и решателю удалось это доказать, то он возвращает \texttt{UNSAT}. Помимо этих результатов, решатель может вернуть \texttt{UNKNOWN} или зависнуть, так как некоторые теории или их комбинации являются неразрешимыми.

Среди теорий, поддерживаемых решателями, можно выделить следующие: теория линейной целочисленной арифметики, линейной вещественной арифметики, неинтерпретированных функций, а также массивов.

\emph{Теория линейной целочисленной арифметики.} Сигнатура данной теории включает в себя целые числа, операции сложения и вычитания, а также предикаты равенства и меньше. Данная теория является разрешимым фрагментом арифметики.

\emph{Теория линейной вещественной арифметики.} Сигнатура данной теории логики первого порядка содержит вещественные числа, операции сложения и вычитания, предикаты равенства и меньше. Описанная теория является разрешимой.

\emph{Теория нелинейной целочисленной арифметики.} Сигнатура данной теории включает в себя целые числа, операции сложения, вычитания и умножения, а также предикаты равенства и меньше. Данная теория является неразрешимой~\cite{godel1931formal}.

\emph{Теория нелинейной вещественной арифметики.} Сигнатура данной теории логики первого порядка содержит вещественные числа, операции сложения, вычитания и умножения, предикаты равенства и меньше. Описанная теория является разрешимой~\cite{tarski1998decision}.

\emph{Теория битовых векторов.} В сигнатуру данной теории входят числа, каждое из которых представляет битовый вектор фиксированной длины (представления чисел в машинной арифметике), предикаты равенства и меньше, операции сложения и произведения, а также следующие битовые операции: <<и>>, <<или>>, <<исключающее или>>, <<не>>, <<сдвиг влево>>, <<сдвиг вправо>>, <<конкатенация двух бит-векторов>>, <<взятие подвектора>>. Данная теория является разрешимой~\cite{barrett1998decision}, так как сводится к задаче выполнимости формул логики высказываний.

% ------------- Обзор существующих решений ---------------

\subsection{Модели памяти}
\emph{Модель памяти}~\cite{mandrik}~--- это формальное представление указателя и ссылки, а также формализация результата операций над ними c использованием логических формул. Среди существующих на данный момент методов моделирования операций с памятью можно выделить две группы подходов: модели для для высокоуровневого анализа памяти и для низкоуровневого. Далее отдельно отдельно разберём обе эти группы подходов. Более подробный обзор существующих моделей памяти приведён в статье~\cite{mandrik}.

\subsubsection{Модели высокоуровневого анализа памяти}

Модели высокоуровневого анализа памяти направлены на анализ рекурсивных структур данных заранее неогрниченного размера, однако в общем случае не поддерживают массивы, адресную арифметику и приведения типов указателей. Среди таких моделей выделим \textsc{LISBQ}~\cite{lahiri2008back}.

\paragraph{LISBQ.} Данный способ моделирования операций с памятью основан на LISBQ (Logic of Interpreted Sets and Bounded Quantification)~--- логике интерпретируемых множеств и ограниченной квантификации. Этот метод используется в дедуктивной верификации, например, в инструменте \textsc{HAVOC}~\cite{bornat2000proving}. Для моделирования поведения программы в логике первого порядка модель памяти LISBQ использует теорию линейной целочисленной и вещественной арифметики. Главными минусами данной модели являются отсутствие поддержки массивов, адресной арифметики, приведений типов указателей. Помимо этого основной особенностью этого метода является необходимость аннотаций со стороны пользователя для достижения \emph{точного анализа} (т. е. порождаемые формулы описывают все поведения программы и только их), что влечёт неприменимость данной модели для автоматизированного анализа.

\subsubsection{Модели низкоуровневого анализа памяти}

Модели памяти, выполняющие низкоуровневый анализ памяти, в отличие от моделей высокоуровневого анализа памяти, сфокусированы на анализе массивов, приведении типов указателей, адресной арифметики, однако не поддерживают произвольные свойства рекурсивных структур данных. Первой среди таких моделей рассмотрим \emph{модель памяти на основе анализа алиасов}.

\paragraph{Модель памяти на основе анализа алиасов~\cite{andersen1994program}.} Данный метод моделирования операций с памятью выполняет анализ синонимичных указательных выражений, что позволяет находить указатели, которые могут ссылаться на одну область памяти. Такая модель памяти была использована в инструменте автоматической верификации \textsc{BLAST}~\cite{beyer2007software}. Данный метод ориентирован на области памяти заранее ограниченного размера (например, структуры или значения простых типов). Однако области памяти заранее неограниченного размера (например, массивы переменной длины) в общем случае не поддерживаются, а именно не поддерживается проверка произвольных свойств таких областей~\cite{mandrik}. Также необходимо отметить, что проверка некоторых простых свойств рекурсивных структур данных может быть выполнена в рамках данной модели.
Для кодирования в SMT-решатель этот метод использует теории линейной вещественной арифметики и неинтерпретированных функций. Формулы, порождаемые данным методом, которые моделируют результат операций с памятью, описывают упрощенный результат, дополненный ложными знаниями, из-за чего происходят многочисленные ложные срабатывания. Данная особенность говорит о неприменимости такого моделирования для задачи проверки произвольных свойств программы. Помимо этого, модель памяти с использованием анализа алиасов не подходит для проверки произвольных свойств программ платформы \dotnet{}, так как в этих программах можно выделить область памяти заранее не ограниченного размера (например, массив). Для анализа памяти таких программ используются модели для областей памяти заранее неограниченного размера, среди которых \emph{типизированная модель}.

\paragraph{Типизированная модель~\cite{cohen2009precise}.} Основной идеей данной модели, используемой в дедуктивной верификации, является сужение области возможных локаций, на которые может указывать указатель, благодаря знаниям о типе локаций и указателя. Если типы локации и указателя совпадают, то указатель может указать на данную локацию. Такая информация о типах предоставляется при помощи аннотаций пользователя, что означает неприменимость для автоматизированной верификации. Такая модель памяти была реализована в инструменте дедуктивной верификации VCC2~\cite{cohen2009vcc}. Для моделирования операций с памятью в логике первого порядка типизированная модель памяти использует следующие теории: теорию массивов, линейной целочисленной и вещественной арифметики. Главным недостатком данной модели является отсутствие поддержки произвольных свойств рекурсивных структур данных. Помимо этого, данный метод ориентирован на дедуктивную верификацию, а значит неприменим в автоматической верификации. Улучшением этого метода моделирования операций с памятью является \emph{модель Бурсталла-Борната}.

\paragraph{Модель Бурсталла-Борната~\cite{bornat2000proving}.} Главной идеей данного способа моделирования, применяемого в области частично автоматизированной дедуктивной верификации, является раздельное представление состояния памяти для компонентов составных объектов, иначе говоря, вся моделируемая память программы является массивом, элементы которого~--- это элементы составных объектов. В качестве теорий логики первого порядка для моделирования поведения программы данная модель использует те же теории, что и типизированная модель памяти, т. е. теорию массивов, линейной целочисленной и вещественной арифметики. Основной особенностью такого метода является достижение точного анализа путём требования аннотаций со стороны пользователя, что неприменимо в случае автоматической верификации. Отсутствие поддержки произвольных свойств рекурсивных структур данных, как и в случае с типизированной моделью, является основным минусом. Расширением такой модели памяти является \emph{модель памяти с регионами}.

\paragraph{Модель памяти с регионами~\cite{hubert2007separation}.} Ключевой идеей данной модели памяти для дедуктивной верификации является уменьшение пространства возможных локаций для определённого указателя с помощью добавления понятия \emph{регионов}. \emph{Регионы}~--- такие непересекающиеся множества указательных выражений, что элементы из разных множеств не могут адресовать пересекающиеся области в памяти. Последняя модификация данной модели была представлена в работе~\cite{mandrykin2017memory} М.~У.~Мандрыкина и А.~В.~Хорошилова. Модель памяти с регионами, как и модель Бурсталла-Борната, использует теорию массивов, линейной целочисленной и вещественной арифметики для моделирования операций программы с памятью. Данная модель относится к моделям памяти для дедуктивной верификации, т. е. основывается на аннотациях пользователя, что невозможно в случае автоматической верификации. Недостатки данной модели типичны для моделей низкоуровневого анализа памяти, т. е. отсутствует поддержка произвольных свойств рекурсивных структур данных~\cite{mandrik}.
